package com.fujitsu.edgewareroad.trivyutils.dto.trivyscan;

import java.time.LocalDate;

import org.springframework.util.StringUtils;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fujitsu.edgewareroad.trivyutils.dto.whitelist.WhitelistEntry;

public class TrivyScanWhitelistedVulnerability extends TrivyScanVulnerability {
    @JsonProperty(required = true)
    private String whitelistingReason;
    @JsonProperty(required = true)
    private LocalDate nextReviewDate;
    @JsonProperty(required = false)
    private LocalDate approvalDate = null;
    @JsonProperty(required = false)
    private String approvedBy = null;

    public TrivyScanWhitelistedVulnerability(TrivyScanVulnerability vulnerability, WhitelistEntry whitelistEntry)
    {
        super(vulnerability);
        if (!vulnerability.getVulnerabilityID().equalsIgnoreCase(whitelistEntry.getVulnerabilityID()))
        {
            // Houston we have a problem and we should never have got this far
            throw new IllegalArgumentException("Vulnerability IDs do not match.");
        }

        this.whitelistingReason = whitelistEntry.getReason();
        this.nextReviewDate = whitelistEntry.getNextReviewDate();
        this.approvalDate = whitelistEntry.getApprovalDate();
        this.approvedBy = whitelistEntry.getApprovedBy();
    }

    public String getWhitelistingReason() {
        return whitelistingReason;
    }

    public LocalDate getNextReviewDate() {
        return nextReviewDate;
    }

    public LocalDate getApprovalDate() {
        return approvalDate;
    }

    public String getApprovedBy() {
        return approvedBy;
    }

    public boolean isApproved() {
        return approvalDate != null && !approvalDate.isAfter(LocalDate.now()) && StringUtils.hasText(approvedBy);
    }

    public boolean requiresReview() {
        return nextReviewDate == null || nextReviewDate.isBefore(LocalDate.now());
    }
}
